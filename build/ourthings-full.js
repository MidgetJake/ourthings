/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ourthings/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ourthings/Define.js":
/*!*********************************!*\
  !*** ./src/ourthings/Define.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Define; });\n/** @module Define */\r\n\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Our define class, contains all magic dnumber defines\r\n *\r\n * @author Richard Reynolds richard@nautoguide.com\r\n *\r\n * @example\r\n * // DEFINE = new Define();\r\n *\r\n */\r\nclass Define {\r\n\tconstructor() {\r\n\t\t/**\r\n\t\t * Queue state of operations\r\n\t\t */\r\n\t\tthis.STATUS_LOADING = 0;\r\n\t\tthis.STATUS_LOADED = 1;\r\n\t\tthis.STATUS_RUNNING = 2;\r\n\t\tthis.STATUS_ERROR = 3;\r\n\r\n\t\t/**\r\n\t\t * Render modes\r\n\t\t */\r\n\t\tthis.RENDER_INSERT = 0;\r\n\t\tthis.RENDER_APPEND = 1;\r\n\r\n\r\n\t\t/**\r\n\t\t *  Command types\r\n\t\t */\r\n\r\n\t\tthis.COMMAND_INSTANT = \"Instant\";\r\n\t\tthis.COMMAND_EVENT = \"Event\";\r\n\t\tthis.COMMAND_SUB = \"Sub\";\r\n\r\n\t\t/**\r\n\t\t *  Queue states\r\n\t\t */\r\n\t\tthis.QUEUE_ADDED = 0;\r\n\t\tthis.QUEUE_RUNNING = 1;\r\n\t\tthis.QUEUE_FINISHED = 2;\r\n\t\tthis.QUEUE_ERROR = 3;\r\n\r\n\t\t/**\r\n\t\t * Queueable Finished states\r\n\t\t */\r\n\r\n\t\tthis.FIN_OK = 0;\r\n\t\tthis.FIN_WARNING = 1;\r\n\t\tthis.FIN_ERROR = 2;\r\n\r\n\t\tthis.MEMORY_GARBAGE=\"Garbage\";\r\n\t\tthis.MEMORY_SESSION=\"Session\";\r\n\t\tthis.MEMORY_PERMANENT=\"Permanent\";\r\n\r\n\t\t/**\r\n\t\t *  Console outputs\r\n\t\t */\r\n\t\tthis.CONSOLE_LINE=\"-==ourthings======================================================-\";\r\n\t\tthis.CONSOLE_COL_VT=\"background: #222; color: #bada55\";\r\n\t\tthis.CONSOLE_COL_GREEN=\"background: #222; color: #0f0\";\r\n\t\tthis.CONSOLE_COL_RED=\"background: #222; color: #f00\";\r\n\t\tthis.CONSOLE_COL_AMBER=\"background: #222; color: #f90\";\r\n\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./src/ourthings/Define.js?");

/***/ }),

/***/ "./src/ourthings/Queue.js":
/*!********************************!*\
  !*** ./src/ourthings/Queue.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Define.js */ \"./src/ourthings/Define.js\");\n/** @module ourthings/Queue */\n\n\n/**\n * @classdesc\n *\n * The main queue class\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * // queue = new Queue();\n *\n */\nclass Queue {\n\n\t/**\n\t * Class constructor\n\t */\n\tconstructor(queueablesList) {\n\n\t\tself = this;\n\n\n\t\t/*\n\t\t * Create our DEFINE object for\n\t\t * @type {Define}\n\t\t */\n\t\tself.DEFINE = new _Define_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\t\t/*\n\t\t * Our Queue array\n\t\t *\n\t\t * @type {Array}\n\t\t */\n\t\tself.queue = [];\n\n\n\t\t/*\n\t\t * Queueable items object\n\t\t */\n\t\tself.queueables={};\n\t\t/*\n\t\t * Templates to be loaded\n\t\t * @type {Array}\n\t\t */\n\t\tself.templates = [];\n\n\n\t\t/*\n\t\t * Create a fragment for big dom inserts\n\t\t * @type {DocumentFragment}\n\t\t */\n\t\tself.fragment = document.createDocumentFragment();\n\n\t\t/*\n\t\t * Se our status\n\t\t * @type {number}\n\t\t */\n\t\tself.status = self.DEFINE.STATUS_LOADING;\n\n\t\t/*\n\t\t * Our queue process ID\n\t\t * @type {number}\n\t\t */\n\t\tself.pid = 0;\n\n\t\t/*\n\t\t * Default time for process to be executed after\n\t\t * TODO Platform test / tune\n\t\t * @type {number}\n\t\t */\n\t\tself.defaultTimer = 10;\n\n\n\t\tconsole.clear();\n\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\tconsole.info('ourthings framework https://github.com/nautoguide/ourthings');\n\n\t\t/*\n\t\t * Run init against all our queueables\n\t\t *\n\t\t * This basically passes the queue object (self) though but also for any queueables that require it\n\t\t * starts any promise functions that will result in them becoming active\n\t\t */\n\t\tconsole.log(\"[Queueables]\");\n\t\tfor (let i in queueablesList) {\n\t\t\tself.checkQueueable(i,queueablesList[i]);\n\t\t}\n\n\t\t/*\n\t\t * Initialise the memory\n\t\t */\n\t\twindow.memory={};\n\t\t/*\n\t\t * Load the templates.json\n\t\t */\n\t\tfetch('templates.json', {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t})\n\t\t\t.then(response => self.handleFetchErrors(response))\n\t\t\t.then(response => response.json() )\n\t\t\t.then(function (response) {\n\t\t\t\t/**\n\t\t\t\t * Convert the response to json and start the loader\n\t\t\t\t */\n\t\t\t\tself.templates = response;\n\t\t\t\tself.templateLoader();\n\t\t\t})\n\t\t\t.catch(function (error) {\n\t\t\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\t\t\tconsole.error('Error:', error);\n\t\t\t\tconsole.info(\"Warning this error is probably fatal as I have no templates to load\")\n\t\t\t});\n\t}\n\n\t/**\n\t * Error Handler for fetch calls\n\t * @param response {object} - Fetch response object\n\t * @returns {Object}\n\t */\n\thandleFetchErrors(response) {\n\t\tif (!response.ok) {\n\t\t\tself.status=self.DEFINE.STATUS_ERROR;\n\t\t\tthrow Error(response.statusText);\n\t\t}\n\t\treturn response;\n\t}\n\n\tcheckQueueable(name,obj) {\n\t\tlet self=this;\n\t\tif(self.queueables[name]===undefined) {\n\t\t\tself.queueables[name]=new obj();\n\t\t\tself.queueables[name].init(self);\n\t\t\tconsole.log('Booting Queueable ['+name+']');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function to upcase first letter of string\n\t * @param string\n\t * @return {string}\n\t */\n\tcapitalizeFirstLetter(string) {\n\t\treturn string.charAt(0).toUpperCase() + string.slice(1);\n\t}\n\n\t/**\n\t * Loads templates from the template stack. Recursively calls self until stack is empty\n\t * @returns {void}\n\t */\n\ttemplateLoader() {\n\t\tlet self=this;\n\t\t/*\n\t\t *  Are there any templates to load?\n\t\t *\n\t\t *  If not then we dump the fragment into the dom\n\t\t */\n\t\tif (this.templates.length === 0) {\n\t\t\tdocument.head.appendChild(self.fragment);\n\t\t\t// Clean up the fragment\n\t\t\tself.fragment=document.createDocumentFragment();\n\t\t\t/*\n\t\t\t * Set our status and then process the init template\n\t\t\t */\n\t\t\tself.status=self.DEFINE.STATUS_LOADED;\n\t\t\t/*\n\t\t\t *  TODO once queue generation is working this this pushing to the queue\n\t\t\t *  As currently this is a chain of promises and so everything will error trap back to the loader\n\t\t\t */\n\t\t\tself.templateProcessor(\"#init\",false);\n\t\t\tself.status=self.DEFINE.STATUS_RUNNING;\n\t\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\t\tconsole.log('[Online]');\n\t\t\tconsole.log('queue.show(); # To debug the queue');\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Pop the template off the stack\n\t\t */\n\t\tlet template = this.templates.pop();\n\n\t\tfetch(template, {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'test/html'\n\t\t\t}\n\t\t})\n\t\t\t.then(response => self.handleFetchErrors(response))\n\t\t\t.then(response => response.text())\n\t\t\t.then(function (response) {\n\n\t\t\t\t/*\n\t\t\t\t * Get the template we were sent and add it to the fragment for insertion into the dom\n\t\t\t\t *\n\t\t\t\t * We wrap it in meta tag, this helps improve render speed but still stuck with an innerHTML\n\t\t\t\t * as we don't know the content\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tlet text = response;\n\t\t\t\tlet meta = document.createElement('meta');\n\t\t\t\tmeta.setAttribute(\"name\", \"generator\");\n\t\t\t\tmeta.setAttribute(\"content\", template);\n\t\t\t\tmeta.innerHTML=text;\n\t\t\t\tself.fragment.appendChild(meta);\n\n\t\t\t\t/*\n\t\t\t\t *  Call our self again to process any more templates\n\t\t\t\t */\n\t\t\t\tself.templateLoader();\n\t\t\t})\n\t\t\t.catch(function (error) {\n\t\t\t\tconsole.error('Error:', error);\n\t\t\t\tconsole.info(\"Warning this error is probably fatal as a template specified in templates.json has failed to load or wont process\");\n\t\t\t});\n\t};\n\n\t/**\n\t * Template processor\n\t * Takes a template, process it and places into the dom\n\t * @param templateId {string} - ID of the template\n\t * @param targetId {string|false} - Place in the dom the put the result. In the event of false we process without dom\n\t * @return {boolean} - success status\n\t */\n\ttemplateProcessor(templateId, targetId) {\n\t\tlet self=this;\n\t\tlet commands=[];\n\n\t\tlet templateDom = self.getElement(templateId);\n\t\tif(!templateDom) {\n\t\t\tself.reportError('No valid template','I have no valid template, check the templateId ['+templateId+']');\n\t\t\treturn false;\n\t\t}\n\t\tlet targetDom=undefined;\n\t\tlet templateHTML = templateDom.innerHTML;\n\t\t/*\n\t\t * Pass to the templateParse to build our commands\n\t\t */\n\t\tlet parsedTemplate=self.templateParse(templateHTML,commands);\n\n\t\t/*\n\t\t * Now we pass any var tags {{ }}\n\t\t */\n\t\tparsedTemplate=self.templateVars(parsedTemplate);\n\n\n\t\tif(targetId!==false) {\n\t\t\ttargetDom=self.getElement(targetId);\n\t\t\tif(!targetDom) {\n\t\t\t\tself.reportError('No valid target','I have no valid target to render the template to, check the targetId ['+targetId+']');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tself.renderToDom(targetDom,parsedTemplate);\n\t\t\tself.commandsBind(commands);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Process the template looking for {{}} instances\n\t * @param template\n\t * @return {*}\n\t */\n\ttemplateVars(template) {\n\t\tconst forRegex=/{{#for (.*?)}}([\\s\\S]*?){{\\/for}}/;\n\t\tlet match=undefined;\n\t\twhile (match = forRegex.exec(template)) {\n\t\t\tlet subTemplate='';\n\t\t\tfor(let i in eval(match[1])) {\n\t\t\t\tlet incrementMatch=match[2].replace(/#loop0/,i);\n\t\t\t\tsubTemplate+=self.templateVars(incrementMatch);\n\t\t\t}\n\t\t\ttemplate = template.replace(match[0], subTemplate);\n\t\t}\n\n\t\tconst commandRegex=/{{(.*?)}}/;\n\t\twhile (match = commandRegex.exec(template)) {\n\t\t\ttemplate = template.replace(match[0], self.varsParser(match[1]));\n\t\t}\n\t\treturn template;\n\t}\n\n\t/**\n\t * parse a var string\n\t *\n\t * TODO This is massively insecure. If as user can input {{}} into a form and have it displayed\n\t * to other users they can take over. We either clean all input as you would with <script> etc tags or we\n\t * manually write a parser.\n\t *\n\t * @param parseString\n\t * @return {any}\n\t */\n\tvarsParser(parseString) {\n\t\treturn eval(parseString);\n\t}\n\n\t/**\n\t * Takes a template and runs any template commands contained in it to create a HTML template\n\t * ready to be put into the dom\n\t *\n\t * @param template {string}\n\t * @return {string}\n\t */\n\ttemplateParse(template,commands) {\n\t\tlet commandRegex=/[@\\-](.*?\\);)/;\n\t\tlet match=undefined;\n\t\tlet parentCommand;\n\t\tlet isParent;\n\t\t/*\n\t\t *  Locate all the commands in the template and generate an array of command objects that\n\t\t *  are linked by a reference into the template\n\t\t */\n\t\twhile (match = commandRegex.exec(template)) {\n\t\t\tisParent=match[0][0]==='@';\n\t\t\t/*\n\t\t\t * Generate this command object from the extracted string\n\t\t\t */\n\t\t\tlet command=self.commandParse(match[1],isParent);\n\n\t\t\t/*\n\t\t\t *  In the case of an instant or sub run we don't need to leave anything in the DOM so nuke\n\t\t\t */\n\t\t\tif(command.options.queueRun===self.DEFINE.COMMAND_INSTANT||command.options.queueRun===self.DEFINE.COMMAND_SUB) {\n\t\t\t\ttemplate = template.replace(match[0], \"\");\n\t\t\t} else {\n\t\t\t\ttemplate = template.replace(match[0], \"data-queueable=\\\"CMD\" + commands.length + \"\\\"\");\n\t\t\t}\n\t\t\t/*\n\t\t\t *  Is this a @parent or a -child?\n\t\t\t */\n\t\t\tif(isParent) {\n\t\t\t\t// Set the parent point to current position\n\t\t\t\tparentCommand=commands.length;\n\t\t\t\t/*\n\t\t\t\t *  Is this an event (in which case we need to bind events later). We know this use case because an\n\t\t\t\t *  event will not be instant and it will be a parent\n\t\t\t\t */\n\t\t\t\tif(command.options.queueRun!==self.DEFINE.COMMAND_INSTANT) {\n\t\t\t\t\t/*\n\t\t\t\t\t *  We need to re-extract the command from the template and find the HTML element that this\n\t\t\t\t\t *  belongs to\n\t\t\t\t\t *\n\t\t\t\t\t *  TODO Stub for now as we need to get a working queue first\n\t\t\t\t\t */\n\t\t\t\t\t//let elementMatch=template.match(//)\n\t\t\t\t}\n\n\t\t\t\tcommands.push(command);\n\t\t\t} else {\n\t\t\t\t// If the parent has just been created it won't have child structure\n\t\t\t\tif(commands[parentCommand].commands===undefined) {\n\t\t\t\t\tcommands[parentCommand].commands=[];\n\t\t\t\t}\n\t\t\t\t// Put the command in the parents\n\t\t\t\tcommands[parentCommand].commands.push(command);\n\t\t\t}\n\t\t}\n\t\t// Add the instants to the active queue\n\t\tself.commandsQueue(commands);\n\t\treturn template;\n\t}\n\n\t/**\n\t * Bind the events to the dom based on the command Object\n\t * @param commandObj\n\t */\n\tcommandsBind(commandObj) {\n\t\tlet self=this;\n\t\tfor(let command in commandObj) {\n\t\t\t/*\n\t\t\t * Bind queue elements will not me marked to run instantly so we pick those\n\t\t\t */\n\t\t\tif(commandObj[command].options.queueRun!==self.DEFINE.COMMAND_INSTANT) {\n\t\t\t\t/*\n\t\t\t\t * Find its dom entry using the selector we added\n\t\t\t\t */\n\t\t\t\tlet element=self.getElement(\"[data-queueable=CMD\"+command+\"]\");\n\n\t\t\t\t/*\n\t\t\t\t * Add the event. We flip it over to an instant event now because we want\n\t\t\t\t * it triggered.\n\t\t\t\t */\n\t\t\t\telement.addEventListener(\"click\", function(){\n\t\t\t\t\tcommandObj[command].options.queueRun=self.DEFINE.COMMAND_INSTANT;\n\t\t\t\t\tself.commandsQueue.apply(self,[[commandObj[command]]]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Take the commands array with command objects in it and add them to the queue *if* they are\n\t * marked as instant. IE ready to execute\n\t *\n\t * @param commandObj\n\t */\n\tcommandsQueue(commandObj) {\n\t\tlet self=this;\n\t\tfor(let command in commandObj) {\n\t\t\tif(commandObj[command].options.queueRun===self.DEFINE.COMMAND_INSTANT) {\n\t\t\t\tlet dereference=self.deepCopy(commandObj[command])\n\t\t\t\tself.queue.push(dereference);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t *  Trigger a queue process\n\t\t */\n\t\tself.queueProcess();\n\t}\n\n\t/**\n\t * Force a queue processing\n\t *\n\t * This launches the actual objects using a timeout\n\t */\n\tqueueProcess() {\n\t\tlet self=this;\n\t\t/*\n\t\t *  TODO Only implementing basic queue here for testing. Concepts of active componets etc need importing\n\t\t *  for moho\n\t\t */\n\t\tfor(let item in self.queue) {\n\t\t\t/*\n\t\t\t *  Look for items that are QUEUE_ADDED as they need processing\n\t\t\t *\n\t\t\t *  Ensure the component is online\n\t\t\t */\n\t\t\tif(self.queue[item].state===self.DEFINE.QUEUE_ADDED&&self.queueables[self.queue[item].queueable].ready) {\n\t\t\t\t/*\n\t\t\t\t * Update our state to be running\n\t\t\t\t */\n\t\t\t\tself.queue[item].state=self.DEFINE.QUEUE_RUNNING;\n\t\t\t\t/*\n\t\t\t\t * Assign a pid\n\t\t\t\t */\n\t\t\t\tif(self.queue[item].pid===undefined) {\n\t\t\t\t\tself.queue[item].pid = self.pid;\n\t\t\t\t\tself.pid++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Check if any specific timing is needed\n\t\t\t\t */\n\t\t\t\tself.queue[item].options.queueTimer=self.queue[item].options.queueTimer||self.defaultTimer;\n\n\t\t\t\t/*\n\t\t\t\t *  Launch the function as a time out (so we get control back)\n\t\t\t\t */\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tself.queueables[self.queue[item].queueable].start.apply(self.queueables[self.queue[item].queueable],[self.queue[item].pid,self.queue[item].command,self.queue[item].json,self]);\n\t\t\t\t}, self.queue[item].options.queueTimer);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find a queue item by searching for its PID\n\t * @param pid\n\t * @return {*}\n\t */\n\tfindQueueByPid(pid) {\n\t\tfor(let item in self.queue) {\n\t\t\tif(self.queue[item].pid===pid) {\n\t\t\t\treturn self.queue[item];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Called by queueables to add something to our memory stack\n\t * @param name\n\t * @param value\n\t * @param pid\n\t */\n\tmemory(pid,value,name) {\n\t\tlet self=this;\n\t\tlet command=this.findQueueByPid(pid);\n\t\tif(command) {\n\t\t\tlet origin = name || command.queueable + '.' + command.command;\n\t\t\tlet mode = self.DEFINE.MEMORY_GARBAGE;\n\t\t\tif (command.options.memory)\n\t\t\t\tmode = command.options.memory;\n\t\t\tlet memoryDetails = {\n\t\t\t\tpid: pid,\n\t\t\t\tmode: mode,\n\t\t\t\torigin: origin,\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t\twindow.memory[origin] = memoryDetails;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.reportError(\"Could not set memory\",\"The memory set for pid [\"+pid+\"] could not be found\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcleanMemory(pid) {\n\t\tlet self=this;\n\t\tfor(let i in window.memory) {\n\t\t\tif(window.memory[i].pid===pid&&window.memory[i].mode===self.DEFINE.MEMORY_GARBAGE) {\n\t\t\t\twindow.memory[i]={};\n\t\t\t\tdelete window.memory[i];\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t *  Called to flag a queue item as finished\n\t *\n\t *  Normally hooked down from queueable this is a queue item saying I have finished in mode (see define.js)\n\t *\n\t * @param pid\n\t * @param mode\n\t */\n\tfinished(pid,mode,error) {\n\t\tlet self=this;\n\t\tfor(let item in self.queue) {\n\t\t\t/*\n\t\t\t *  Find the queue item we need to finish\n\t\t\t */\n\t\t\tif(self.queue[item].pid===pid) {\n\t\t\t\tself.queue[item].error=error;\n\t\t\t\tif (self.queue[item].state === self.DEFINE.QUEUE_RUNNING) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Did the command return an error? If so we will stop this queue from further execution\n\t\t\t\t\t */\n\t\t\t\t\tif(mode==self.DEFINE.FIN_ERROR) {\n\t\t\t\t\t\tself.queue[item].state=self.DEFINE.QUEUE_ERROR;\n\t\t\t\t\t\tself.reportError(error,'The queueable ['+pid+'] has errored, queue put on hold');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * Was there a warning?. This isn't serious so we just mention it to the console\n\t\t\t\t\t */\n\t\t\t\t\tif(mode==self.DEFINE.FIN_WARNING) {\n\t\t\t\t\t\tconsole.log('Warning: '+error);\n\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Check if this queue has commands left\n\t\t\t\t\t\t */\n\t\t\t\t\tif(self.queue[item].commands!==undefined&&self.queue[item].commands.length>0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Move the next item in the queue down\n\t\t\t\t\t\t */\n\t\t\t\t\t\tself.queue[item].command=self.queue[item].commands[0].command;\n\t\t\t\t\t\tself.queue[item].queueable=self.queue[item].commands[0].queueable;\n\t\t\t\t\t\tself.queue[item].json=self.queue[item].commands[0].json;\n\t\t\t\t\t\tself.queue[item].options=self.queue[item].commands[0].options;\n\t\t\t\t\t\tself.queue[item].commands.shift();\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t *  Update the pid\n\t\t\t\t\t\t *  TODO remove this as queues need to maintain their Pid for memory\n\t\t\t\t\t\t */\n\t\t\t\t\t\t//self.queue[item].pid=self.pid;\n\t\t\t\t\t\t//self.pid++;\n\t\t\t\t\t\tself.queue[item].state = self.DEFINE.QUEUE_ADDED;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Start the queue processor as we just posted a new command\n\t\t\t\t\t\t */\n\t\t\t\t\t\tself.queueProcess();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.queue[item].state = self.DEFINE.QUEUE_FINISHED;\n\t\t\t\t\t\tself.cleanMemory(self.queue[item].pid);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tself.reportError('Cant stop an already stopped process ['+pid+']','Queue is corrupted');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This will take a command string in the format object.command({},{}); and split it down\n\t * into it parts as an object\n\t *\n\t * TODO no concept of the context of the command IE was it from inside a div that need binding?\n\t * @param command {string}\n\t * @return {object}\n\t */\n\tcommandParse(command,isParent) {\n\t\tlet self=this;\n\t\tlet commandObject={};\n\t\t// Find the actual command\n\t\tlet commandArray=command.match(/(.*?)\\(/)[1].split('.');\n\t\tcommandObject.queueable=commandArray[0];\n\t\tcommandObject.command=commandArray[1];\n\t\t// Strip as we go to make follow up regex easier\n\t\tcommand=command.replace(/.*?\\(/,'');\n\t\t// Find first json arg\n\t\tlet json=command.match(/(\\{.*?\\})/);\n\t\tcommand=command.replace(/\\{.*?\\}[,]{0,1}/,'');\n\t\tif(command[1]) {\n\t\t\tcommandObject.json = JSON.parse(json[1]);\n\t\t} else {\n\t\t\tcommandObject.json={};\n\t\t}\n\n\t\t// Find second json arg\n\t\tlet jsonOptions=command.match(/(\\{.*?\\})/);\n\t\tif(Array.isArray(jsonOptions) && jsonOptions[1]) {\n\t\t\tcommandObject.options = JSON.parse(jsonOptions[1]);\n\t\t} else {\n\t\t\tcommandObject.options={};\n\t\t}\n\t\t/*\n\t\t * Set our default options if they haven't been set\n\t\t *\n\t\t * We must always have a queueRun object if its not set (normally by instant) then its either an event in\n\t\t * which case it must be a parent or failing then its a sub\n\t\t *\n \t\t */\n\t\tcommandObject.options.queueRun=commandObject.options.queueRun||(isParent? self.DEFINE.COMMAND_EVENT:self.DEFINE.COMMAND_SUB);\n\t\tcommandObject.state=self.DEFINE.QUEUE_ADDED;\n\t\treturn commandObject;\n\t}\n\n\t/**\n\t * Render some text/html to the dom\n\t * @param domObject {object} - The object in the dom to write to\n\t * @param text {string} - The text/HTML to write\n\t * @param mode {number} - Mode to use while writing see define.js\n\t * @return {boolean}\n\t */\n\trenderToDom(domObject,text,mode) {\n\t\tlet self=this;\n\t\tmode=mode||self.DEFINE.RENDER_INSERT;\n\t\tswitch(mode) {\n\t\t\tcase self.DEFINE.RENDER_INSERT:\n\t\t\t\tdomObject.innerHTML=text;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Finds an element in the dom using the jquery formant IE #id .class tag\n\t * @param elementTarget\n\t * @return {object|false}\n\t */\n\tgetElement(elementTarget) {\n\t\tlet self=this;\n\t\tlet element=document.querySelector(elementTarget);\n\t\tif(element!==null)\n\t\t\treturn element;\n\t\tself.reportError('Dom Element find failed for ['+elementTarget+']','Follow up calls that rely on this will fail');\n\t\treturn false;\n\t}\n\n\t/**\n\t *  Show current queue status in the console DEBUG function\n\t */\n\tshow() {\n\t\tlet self=this;\n\t\tfor(let i in self.queue) {\n\t\t\tlet indent=0;\n\t\t\tself.prettyCommandObject(self.queue[i],indent);\n\t\t\tfor(let j in self.queue[i].commands) {\n\t\t\t\tindent++;\n\t\t\t\tself.prettyCommandObject(self.queue[i].commands[j],indent);\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Make a pretty version of the currrent commandObject and dump it to the console\n\t * @param commandObject\n\t * @param indent\n\t */\n\tprettyCommandObject(commandObject,indent) {\n\t\tlet string='';\n\t\tfor(var i=0;i<indent;i++) {\n\t\t\tstring+=' ';\n\t\t}\n\t\tlet color=self.DEFINE.CONSOLE_COL_GREEN;\n\t\tswitch(commandObject.state) {\n\t\t\tcase self.DEFINE.QUEUE_FINISHED:\n\t\t\t\tcolor=self.DEFINE.CONSOLE_COL_AMBER;\n\t\t\t\tbreak;\n\t\t\tcase self.DEFINE.QUEUE_ERROR:\n\t\t\t\tcolor=self.DEFINE.CONSOLE_COL_RED;\n\t\t\t\tbreak;\n\n\t\t}\n\t\tstring+=commandObject.queueable+'.'+commandObject.command+'('+JSON.stringify(commandObject.json)+','+JSON.stringify(commandObject.options)+');'\n\t\tconsole.log('%c '+string,color);\n\t\tif(commandObject.error)\n\t\t\tconsole.log('%c  Stopped: '+commandObject.error,self.DEFINE.CONSOLE_COL_AMBER);\n\t}\n\n\t/**\n\t * Report an error to the console, adds various internal stats\n\t * @param error\n\t * @param message\n\t */\n\treportError(error,message) {\n\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\tconsole.error('Error:', error);\n\t\tconsole.info(message);\n\t}\n\n\t/**\n\t * Deep copy and object IE remove references\n\t * @param inputObject\n\t * @return {any}\n\t */\n\tdeepCopy(inputObject) {\n\t\treturn JSON.parse(JSON.stringify(inputObject));\n\t}\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Queue);\n\n//# sourceURL=webpack:///./src/ourthings/Queue.js?");

/***/ }),

/***/ "./src/ourthings/Queueable.js":
/*!************************************!*\
  !*** ./src/ourthings/Queueable.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** @module ourthings/Queueable */\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * The base class for queueable things\r\n *\r\n * @author Richard Reynolds richard@nautoguide.com\r\n *\r\n * @example\r\n * // queue = new Queue();\r\n *\r\n */\r\nclass Queueable {\r\n\r\n\t/**\r\n\t * Constructor, Sets our status to be false (flipped on init)\r\n\t *\r\n\t */\r\n\tconstructor() {\r\n\t\tlet self=this;\r\n\t\tself.ready=false;\r\n\t}\r\n\r\n\t/**\r\n\t * init, override this for any promise based inits setting\r\n\t * the self.ready=true after the promise\r\n\t *\r\n\t */\r\n\tinit(queue) {\r\n\t\tlet self=this;\r\n\t\tself.queue=queue;\r\n\t\tself.ready=true;\r\n\t}\r\n\r\n\t/**\r\n\t * Called from queue, starts running the actual command\r\n\t * @param pid\r\n\t * @param command\r\n\t * @param json\r\n\t */\r\n\tstart(pid,command,json) {\r\n\t\tlet self=this;\r\n\t\tif(self[command]&&typeof self[command] === 'function') {\r\n\r\n\t\t\t/*\r\n\t\t\t * Pass the json through the var processor\r\n\t\t\t */\r\n\r\n\t\t\tjson=JSON.parse(self.queue.templateVars(JSON.stringify(json)));\r\n\t\t\t/*\r\n\t\t\t * Execute\r\n\t\t\t */\r\n\t\t\tself[command](pid, json);\r\n\t\t} else {\r\n\t\t\tself.queue.finished(pid,self.queue.DEFINE.FIN_ERROR,'No such command ['+command+']');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Call this method after you command has finished. Failure to do so will result is\r\n\t * a stalled queue\r\n\t * @param pid\r\n\t * @param mode\r\n\t */\r\n\tfinished(pid,mode,error='') {\r\n\t\tlet self=this;\r\n\t\tself.queue.finished(pid,mode,error);\r\n\t}\r\n\r\n\tset(pid,value,name) {\r\n\t\tlet self=this;\r\n\t\tself.queue.memory(pid,value,name);\r\n\t}\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Queueable);\n\n//# sourceURL=webpack:///./src/ourthings/Queueable.js?");

/***/ }),

/***/ "./src/ourthings/Queueable/Api.js":
/*!****************************************!*\
  !*** ./src/ourthings/Queueable/Api.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Api; });\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Queueable */ \"./src/ourthings/Queueable.js\");\n/** @module Api */\r\n\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Dom Elements manipulations\r\n *\r\n * @author Richard Reynolds richard@nautoguide.com\r\n *\r\n * @example\r\n * //\r\n *\r\n */\r\nclass Api extends _Queueable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\r\n\t/**\r\n\t * Render a template into the dom using the queues templateProcessor\r\n\t * @param pid\r\n\t * @param json\r\n\t */\r\n\tget(pid,json) {\r\n\t\tlet self=this;\r\n\r\n\t\tfetch(json.url, {\r\n\t\t\theaders: {\r\n\t\t\t\t'Content-Type': 'application/json'\r\n\t\t\t}\r\n\t\t})\r\n\t\t\t.then(response => self.queue.handleFetchErrors(response))\r\n\t\t\t.then(response => response.json() )\r\n\t\t\t.then(function (response) {\r\n\t\t\t\t/**\r\n\t\t\t\t * Convert the response to json and start the loader\r\n\t\t\t\t */\r\n\t\t\t\tself.set(pid,response);\r\n\t\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\r\n\r\n\t\t\t})\r\n\t\t\t.catch(function (error) {\r\n\t\t\t\tconsole.info(self.queue.DEFINE.CONSOLE_LINE);\r\n\t\t\t\tconsole.error('Error:', error);\r\n\t\t\t\tconsole.info(\"Warning this error is probably fatal as I have no templates to load\")\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/ourthings/Queueable/Api.js?");

/***/ }),

/***/ "./src/ourthings/Queueable/Elements.js":
/*!*********************************************!*\
  !*** ./src/ourthings/Queueable/Elements.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Elements; });\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Queueable */ \"./src/ourthings/Queueable.js\");\n/** @module ourthings/Queueable/Elements */\r\n\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Dom Elements manipulations\r\n *\r\n * @author Richard Reynolds richard@nautoguide.com\r\n *\r\n * @example\r\n * //\r\n *\r\n */\r\nclass Elements extends _Queueable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\r\n\t/**\r\n\t * Render a template into the dom using the queues templateProcessor\r\n\t * @param pid\r\n\t * @param json\r\n\t */\r\n\taddClass(pid,json) {\r\n\t\tlet self=this;\r\n\t\tlet element=self.queue.getElement(json.targetId);\r\n\t\tself.set(pid,json);\r\n\r\n\t\tif(element!==false) {\r\n\t\t\telement.classList.add(json.class);\r\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\r\n\t\t} else {\r\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_WARNING,'Could not add class ['+json.class+'] to ['+json.targetId+']');\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/ourthings/Queueable/Elements.js?");

/***/ }),

/***/ "./src/ourthings/Queueable/Templates.js":
/*!**********************************************!*\
  !*** ./src/ourthings/Queueable/Templates.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Queueable */ \"./src/ourthings/Queueable.js\");\n/** @module ourthings/Queueable/Templates */\r\n\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Template manipulations\r\n *\r\n * @author Richard Reynolds richard@nautoguide.com\r\n *\r\n * @example\r\n * // @templates.render({\"targetId\":\"content\",\"template\":\"basic\"},{\"queueRun\":\"Instant\"});\r\n *\r\n */\r\nclass Templates extends _Queueable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\r\n\t/**\r\n\t * Render a template into the dom using the queues templateProcessor\r\n\t * @param pid\r\n\t * @param json\r\n\t */\r\n\trender(pid,json) {\r\n\t\tlet self=this;\r\n\t\tself.set(pid,json);\r\n\t\tif(!self.queue.templateProcessor(json.template,json.targetId))\r\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_ERROR,'Could not render template');\r\n\t\telse\r\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\r\n\t}\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Templates);\n\n//# sourceURL=webpack:///./src/ourthings/Queueable/Templates.js?");

/***/ }),

/***/ "./src/ourthings/main.js":
/*!*******************************!*\
  !*** ./src/ourthings/main.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ \"./src/ourthings/Queue.js\");\n/* harmony import */ var _Queueable_Templates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queueable/Templates */ \"./src/ourthings/Queueable/Templates.js\");\n/* harmony import */ var _Queueable_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Queueable/Elements */ \"./src/ourthings/Queueable/Elements.js\");\n/* harmony import */ var _Queueable_Api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Queueable/Api */ \"./src/ourthings/Queueable/Api.js\");\n\n\n/**\n *  Import all the queueables we want to use here. Make sure to add an entry to window.queueables bellow to\n *  construct the object\n *\n *  TODO Figure a way to get list of imported queuaables from webpack (plugin?)\n */\n\n\n\n\n/**\n * On load initiate the queue object\n *\n * And setup our queueables\n *\n */\n\nlet queue;\nqueue = new _Queue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\"templates\":_Queueable_Templates__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\"elements\":_Queueable_Elements__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\"api\":_Queueable_Api__WEBPACK_IMPORTED_MODULE_3__[\"default\"]});\nwindow.queue=queue;\n\n\n//# sourceURL=webpack:///./src/ourthings/main.js?");

/***/ })

/******/ });