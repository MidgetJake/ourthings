/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@nautoguide/ourthings/Define.js":
/*!******************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/Define.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Define; });\n/** @module Define */\n\n\n/**\n * @classdesc\n *\n * Our define class, contains all magic dnumber defines\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * // DEFINE = new Define();\n *\n */\nclass Define {\n\tconstructor() {\n\t\t/**\n\t\t * Queue state of operations\n\t\t */\n\t\tthis.STATUS_LOADING = 0;\n\t\tthis.STATUS_LOADED = 1;\n\t\tthis.STATUS_RUNNING = 2;\n\t\tthis.STATUS_ERROR = 3;\n\n\t\t/**\n\t\t * Render modes\n\t\t */\n\t\tthis.RENDER_INSERT = 0;\n\t\tthis.RENDER_APPEND = 1;\n\n\n\t\t/**\n\t\t *  Command types\n\t\t */\n\n\t\tthis.COMMAND_INSTANT = \"Instant\";\n\t\tthis.COMMAND_EVENT = \"Event\";\n\t\tthis.COMMAND_SUB = \"Sub\";\n\n\t\t/**\n\t\t *  Queue states\n\t\t */\n\t\tthis.QUEUE_ADDED = 0;\n\t\tthis.QUEUE_RUNNING = 1;\n\t\tthis.QUEUE_FINISHED = 2;\n\t\tthis.QUEUE_ERROR = 3;\n\n\t\t/**\n\t\t * Queueable Finished states\n\t\t */\n\n\t\tthis.FIN_OK = 0;\n\t\tthis.FIN_WARNING = 1;\n\t\tthis.FIN_ERROR = 2;\n\n\t\tthis.MEMORY_GARBAGE=\"Garbage\";\n\t\tthis.MEMORY_SESSION=\"Session\";\n\t\tthis.MEMORY_PERMANENT=\"Permanent\";\n\n\t\t/**\n\t\t *  Console outputs\n\t\t */\n\t\tthis.CONSOLE_LINE=\"-==ourthings======================================================-\";\n\t\tthis.CONSOLE_COL_VT=\"background: #222; color: #bada55\";\n\t\tthis.CONSOLE_COL_GREEN=\"background: #222; color: #0f0\";\n\t\tthis.CONSOLE_COL_RED=\"background: #222; color: #f00\";\n\t\tthis.CONSOLE_COL_AMBER=\"background: #222; color: #f90\";\n\n\t}\n}\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/Define.js?");

/***/ }),

/***/ "./node_modules/@nautoguide/ourthings/Queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/Queue.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Define.js */ \"./node_modules/@nautoguide/ourthings/Define.js\");\n/** @module ourthings/Queue */\n\n\n/**\n * @classdesc\n *\n * The main queue class\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * let queue = new Queue();\n */\nclass Queue {\n\n\t/**\n\t * Class constructor\n\t */\n\tconstructor(queueablesList) {\n\n\t\tself = this;\n\n\n\t\t/*\n\t\t * Create our DEFINE object for\n\t\t * @type {Define}\n\t\t */\n\t\tself.DEFINE = new _Define_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\t\t/*\n\t\t * Our Queue array\n\t\t *\n\t\t * @type {Array}\n\t\t */\n\t\tself.queue = [];\n\n\t\t/*\n\t\t * Our events (queues) which can be called by name\n\t\t */\n\t\tself.prepare = {};\n\n\n\t\t/*\n\t\t * Queueable items object\n\t\t */\n\t\tself.queueables={};\n\t\t/*\n\t\t * Templates to be loaded\n\t\t * @type {Array}\n\t\t */\n\t\tself.templates = [];\n\n\n\t\t/*\n\t\t * Create a fragment for big dom inserts\n\t\t * @type {DocumentFragment}\n\t\t */\n\t\tself.fragment = document.createDocumentFragment();\n\n\t\t/*\n\t\t * Se our status\n\t\t * @type {number}\n\t\t */\n\t\tself.status = self.DEFINE.STATUS_LOADING;\n\n\t\t/*\n\t\t * Our queue process ID\n\t\t * @type {number}\n\t\t */\n\t\tself.pid = 0;\n\n\t\t/*\n\t\t * Default time for process to be executed after\n\t\t * TODO Platform test / tune\n\t\t * @type {number}\n\t\t */\n\t\tself.defaultTimer = 10;\n\n\n\t\tconsole.clear();\n\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\tconsole.info('ourthings framework https://github.com/nautoguide/ourthings');\n\n\t\t/*\n\t\t * Run init against all our queueables\n\t\t *\n\t\t * This basically passes the queue object (self) though but also for any queueables that require it\n\t\t * starts any promise functions that will result in them becoming active\n\t\t */\n\t\tconsole.log(\"[Queueables]\");\n\t\tfor (let i in queueablesList) {\n\t\t\tself.checkQueueable(i,queueablesList[i]);\n\t\t}\n\n\t\t/*\n\t\t * Initialise the memory\n\t\t */\n\t\twindow.memory={};\n\n\t\t/*\n\t\t * Load any perm cookies\n\t\t */\n\t\tself._loadMemoryPerms();\n\t\t/*\n\t\t * Load the templates.json\n\t\t */\n\t\tfetch('templates.json', {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t})\n\t\t\t.then(response => self.handleFetchErrors(response))\n\t\t\t.then(response => response.json() )\n\t\t\t.then(function (response) {\n\t\t\t\t/**\n\t\t\t\t * Convert the response to json and start the loader\n\t\t\t\t */\n\t\t\t\tself.templates = response;\n\t\t\t\tself.templateLoader();\n\t\t\t})\n\t\t\t.catch(function (error) {\n\t\t\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\t\t\tconsole.error('Error:', error);\n\t\t\t\tconsole.info(\"Warning this error is probably fatal as I have no templates to load\")\n\t\t\t});\n\t}\n\n\t/**\n\t * Error Handler for fetch calls\n\t * @param response {object} - Fetch response object\n\t * @returns {Object}\n\t */\n\thandleFetchErrors(response) {\n\t\tif (!response.ok) {\n\t\t\tself.status=self.DEFINE.STATUS_ERROR;\n\t\t\tthrow Error(response.statusText);\n\t\t}\n\t\treturn response;\n\t}\n\n\tcheckQueueable(name,obj) {\n\t\tlet self=this;\n\t\tif(self.queueables[name]===undefined) {\n\t\t\tself.queueables[name]=new obj();\n\t\t\tself.queueables[name].init(self);\n\t\t\tconsole.log('Booting Queueable ['+name+']');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function to upcase first letter of string\n\t * @param string\n\t * @return {string}\n\t */\n\tcapitalizeFirstLetter(string) {\n\t\treturn string.charAt(0).toUpperCase() + string.slice(1);\n\t}\n\n\t/**\n\t * Loads templates from the template stack. Recursively calls self until stack is empty\n\t * @returns {void}\n\t */\n\ttemplateLoader() {\n\t\tlet self=this;\n\t\t/*\n\t\t *  Are there any templates to load?\n\t\t *\n\t\t *  If not then we dump the fragment into the dom\n\t\t */\n\t\tif (this.templates.length === 0) {\n\t\t\tdocument.head.appendChild(self.fragment);\n\t\t\t// Clean up the fragment\n\t\t\tself.fragment=document.createDocumentFragment();\n\t\t\t/*\n\t\t\t * Set our status and then process the init template\n\t\t\t */\n\t\t\tself.status=self.DEFINE.STATUS_LOADED;\n\t\t\t/*\n\t\t\t *  TODO once queue generation is working this this pushing to the queue\n\t\t\t *  As currently this is a chain of promises and so everything will error trap back to the loader\n\t\t\t */\n\t\t\tself.templateProcessor(\"#init\",false);\n\t\t\tself.status=self.DEFINE.STATUS_RUNNING;\n\t\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\t\tconsole.log('[Online]');\n\t\t\tconsole.log('queue.show(); # To debug the queue');\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Pop the template off the stack\n\t\t */\n\t\tlet template = this.templates.pop();\n\n\t\tfetch(template, {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'test/html'\n\t\t\t}\n\t\t})\n\t\t\t.then(response => self.handleFetchErrors(response))\n\t\t\t.then(response => response.text())\n\t\t\t.then(function (response) {\n\n\t\t\t\t/*\n\t\t\t\t * Get the template we were sent and add it to the fragment for insertion into the dom\n\t\t\t\t *\n\t\t\t\t * We wrap it in meta tag, this helps improve render speed but still stuck with an innerHTML\n\t\t\t\t * as we don't know the content\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tlet text = response;\n\t\t\t\tlet meta = document.createElement('meta');\n\t\t\t\tmeta.setAttribute(\"name\", \"generator\");\n\t\t\t\tmeta.setAttribute(\"content\", template);\n\t\t\t\tmeta.innerHTML=text;\n\t\t\t\tself.fragment.appendChild(meta);\n\n\t\t\t\t/*\n\t\t\t\t *  Call our self again to process any more templates\n\t\t\t\t */\n\t\t\t\tself.templateLoader();\n\t\t\t})\n\t\t\t.catch(function (error) {\n\t\t\t\tconsole.error('Error:', error);\n\t\t\t\tconsole.info(\"Warning this error is probably fatal as a template specified in templates.json has failed to load or wont process\");\n\t\t\t});\n\t};\n\n\t/**\n\t * Template processor\n\t * Takes a template, process it and places into the dom\n\t * @param templateId {string} - ID of the template\n\t * @param targetId {string|false} - Place in the dom the put the result. In the event of false we process without dom\n\t * @return {boolean|string} - success status\n\t */\n\ttemplateProcessor(templateId, targetId) {\n\t\tlet self=this;\n\t\tlet commands=[];\n\n\t\tlet templateDom = self.getElement(templateId);\n\t\tif(!templateDom) {\n\t\t\tself.reportError('No valid template','I have no valid template, check the templateId ['+templateId+']');\n\t\t\treturn false;\n\t\t}\n\t\tlet targetDom=undefined;\n\t\tlet templateHTML = templateDom.innerHTML;\n\t\t/*\n\t\t * Pass all out tags {{ }} First\n\t\t *\n\t\t * TODO we need to split this so only loop etc is done first, then pass to templateParse then parse\n\t\t * out {{eval}} when the command queues are gone to prevent executing too early\n\t\t */\n\t\tlet parsedTemplate=self.templateVars(templateHTML);\n\t\t/*\n\t\t * now pass to the templateParse to build our commands\n\t\t */\n\t\tparsedTemplate=self.templateParse(parsedTemplate,commands);\n\n\t\tif(targetId===\"return\")\n\t\t\treturn parsedTemplate;\n\n\n\t\tif(targetId!==false) {\n\t\t\ttargetDom=self.getElement(targetId);\n\t\t\tif(!targetDom) {\n\t\t\t\tself.reportError('No valid target','I have no valid target to render the template to, check the targetId ['+targetId+']');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tself.renderToDom(targetDom,parsedTemplate);\n\t\t\tself.commandsBind(commands);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Process the template looking for {{}} instances\n\t * @param template\n\t * @return {*}\n\t */\n\ttemplateVars(template) {\n\t\tlet match;\n\n\t\t/*\n\t\t * Process {{#if}}\n\t\t */\n\t\tconst ifRegex=/{{#if (.*?)}}([\\s\\S]*?){{\\/if}}/;\n\t\twhile (match = ifRegex.exec(template)) {\n\t\t\tif (eval(match[1]))\n\t\t\t\ttemplate = template.replace(match[0], self.templateVars(match[2]));\n\t\t\telse\n\t\t\t\ttemplate = template.replace(match[0], '');\n\t\t}\n\n\t\t/*\n\t\t * Look for {{#for}} loops and execute them\n\t\t */\n\t\tconst forRegex=/{{#for (.*?)}}([\\s\\S]*?){{\\/for}}/;\n\t\twhile (match = forRegex.exec(template)) {\n\t\t\tlet subTemplate='';\n\t\t\t/*\n\t\t\t * loop through making sub templates as we go\n\t\t\t */\n\t\t\tfor(let i in eval(match[1])) {\n\t\t\t\tlet incrementMatch=match[2].replace(/#loop0/g,i);\n\t\t\t\tsubTemplate+=self.templateVars(incrementMatch);\n\t\t\t}\n\t\t\ttemplate = template.replace(match[0], subTemplate);\n\t\t}\n\n\t\t/*\n\t\t * Look for any includes to directly inject templates\n\t\t */\n\t\tconst includeRegex=/{{#include (.*?)}}/;\n\t\twhile (match = includeRegex.exec(template)) {\n\t\t\ttemplate = template.replace(match[0], self.templateProcessor(match[1],\"return\"));\n\t\t}\n\n\t\t/*\n\t\t * Process any other {{}} tags but not if they have {{!}} as those are done on command exec time\n\t\t */\n\t\tconst commandRegex=/{{([^!|~].*?)}}/;\n\t\twhile (match = commandRegex.exec(template)) {\n\t\t\ttemplate = template.replace(match[0], self.varsParser(match[1]));\n\t\t}\n\t\treturn template;\n\t}\n\n\t/**\n\t * Process a json object and replace {{!}} tags\n\t * @param json\n\t * @return {any}\n\t */\n\tjsonVars(json) {\n\t\tjson=JSON.stringify(json);\n\t\tconst commandRegex=/{{!(.*?)}}/;\n\t\tlet match;\n\t\twhile (match = commandRegex.exec(json)) {\n\t\t\tjson = json.replace(match[0], self.varsParser(match[1]));\n\t\t}\n\t\treturn JSON.parse(json);\n\t}\n\t/**\n\t * parse a var string\n\t *\n\t * TODO This is massively insecure. If as user can input {{}} into a form and have it displayed\n\t * to other users they can take over. We either clean all input as you would with <script> etc tags or we\n\t * manually write a parser.\n\t *\n\t * @param parseString\n\t * @return {any}\n\t */\n\tvarsParser(parseString) {\n\t\treturn eval(parseString);\n\t}\n\n\t/**\n\t * Takes a template and runs any template commands contained in it to create a HTML template\n\t * ready to be put into the dom\n\t *\n\t * @param template {string}\n\t * @return {string}\n\t */\n\ttemplateParse(template,commands) {\n\t\tlet commandRegex=/[@\\-](.*\\);)/;\n\t\tlet match=undefined;\n\t\tlet parentCommand;\n\t\tlet isParent;\n\t\t/*\n\t\t *  Locate all the commands in the template and generate an array of command objects that\n\t\t *  are linked by a reference into the template\n\t\t */\n\t\twhile (match = commandRegex.exec(template)) {\n\t\t\tisParent=match[0][0]==='@';\n\t\t\t/*\n\t\t\t * Generate this command object from the extracted string\n\t\t\t */\n\t\t\tlet command=self.commandParse(match[1],isParent);\n\n\t\t\t/*\n\t\t\t *  In the case of an instant or sub run we don't need to leave anything in the DOM so nuke\n\t\t\t */\n\t\t\tif(command.options.queueRun===self.DEFINE.COMMAND_INSTANT||command.options.queueRun===self.DEFINE.COMMAND_SUB) {\n\t\t\t\ttemplate = template.replace(match[0], \"\");\n\t\t\t} else {\n\t\t\t\ttemplate = template.replace(match[0], \"data-queueable=\\\"CMD\" + commands.length + \"\\\"\");\n\t\t\t}\n\t\t\t/*\n\t\t\t *  Is this a @parent or a -child?\n\t\t\t */\n\t\t\tif(isParent) {\n\t\t\t\t// Set the parent point to current position\n\t\t\t\tparentCommand=commands.length;\n\n\t\t\t\tcommands.push(command);\n\t\t\t} else {\n\t\t\t\t// If the parent has just been created it won't have child structure\n\t\t\t\tif(commands[parentCommand].commands===undefined) {\n\t\t\t\t\tcommands[parentCommand].commands=[];\n\t\t\t\t}\n\t\t\t\t// Put the command in the parents\n\t\t\t\tcommands[parentCommand].commands.push(command);\n\t\t\t}\n\t\t}\n\t\t// Add the instants to the active queue\n\t\tself.commandsQueue(commands);\n\t\treturn template;\n\t}\n\n\t/**\n\t * Bind the events to the dom based on the command Object\n\t * @param commandObj\n\t */\n\tcommandsBind(commandObj) {\n\t\tlet self=this;\n\t\tfor(let command in commandObj) {\n\t\t\t/*\n\t\t\t * Bind queue elements will not me marked to run instantly so we pick those\n\t\t\t */\n\t\t\tif(commandObj[command].options.queueRun!==self.DEFINE.COMMAND_INSTANT) {\n\t\t\t\t/*\n\t\t\t\t * Find its dom entry using the selector we added\n\t\t\t\t */\n\t\t\t\tlet element=self.getElement(\"[data-queueable=CMD\"+command+\"]\");\n\n\t\t\t\t/*\n\t\t\t\t * Add the event. We flip it over to an instant event now because we want\n\t\t\t\t * it triggered.\n\t\t\t\t */\n\t\t\t\telement.addEventListener(\"click\", function(){\n\t\t\t\t\tcommandObj[command].options.queueRun=self.DEFINE.COMMAND_INSTANT;\n\t\t\t\t\tself.commandsQueue.apply(self,[[commandObj[command]]]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Take the commands array with command objects in it and add them to the queue *if* they are\n\t * marked as instant. IE ready to execute\n\t *\n\t * @param commandObj\n\t */\n\tcommandsQueue(commandObj) {\n\t\tlet self=this;\n\t\tfor(let command in commandObj) {\n\t\t\t/*\n\t\t\t * DEFINE.COMMAND_INSTANT, basically a queue item we need to get running\n\t\t\t */\n\t\t\tif(commandObj[command].options.queueRun===self.DEFINE.COMMAND_INSTANT) {\n\t\t\t\tself.queue.push(self.deepCopy(commandObj[command]));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Is the a prepare queue that will be triggered at some later stage\n\t\t\t */\n\t\t\tif(commandObj[command].options.queuePrepare!== undefined) {\n\t\t\t\tself.prepare[commandObj[command].options.queuePrepare]=self.deepCopy(commandObj[command]);\n\t\t\t\tconsole.log('Added Prepared Queue ['+commandObj[command].options.queuePrepare+']');\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t *  Trigger a queue process\n\t\t */\n\t\tself.queueProcess();\n\t}\n\n\t/**\n\t * Execute a queue that is loaded into prepare\n\t *\n\t * @param prepareName {string} Name of the prepared queue\n\t * @param json {object}\n\t */\n\texecute(prepareName,json) {\n\t\tlet self=this;\n\t\tif(self.prepare[prepareName]!==undefined) {\n\t\t\t/*\n\t\t\t * Take a copy of the prepared command as we need to alter it\n\t\t\t * and possibly pass new params then add it to the queue\n\t\t\t */\n\t\t\tlet dereferenceCommand=self.deepCopy(self.prepare[prepareName]);\n\t\t\tdereferenceCommand.options.queueRun=self.DEFINE.COMMAND_INSTANT;\n\t\t\tif(json!==undefined)\n\t\t\t\tdereferenceCommand.json=json;\n\t\t\tself.commandsQueue.apply(self,[[dereferenceCommand]]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tself.reportError(\"Can not execute prepare [\"+prepareName+\"]\",\"The prepared queue you requested does not exist\");\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\t/**\n\t * Force a queue processing\n\t *\n\t * This launches the actual objects using a timeout\n\t */\n\tqueueProcess() {\n\t\tlet self=this;\n\t\t/*\n\t\t *  TODO Only implementing basic queue here for testing. Concepts of active componets etc need importing\n\t\t *  for moho\n\t\t */\n\t\tfor(let item in self.queue) {\n\t\t\t/*\n\t\t\t *  Look for items that are QUEUE_ADDED as they need processing\n\t\t\t *\n\t\t\t *  Ensure the component is online\n\t\t\t */\n\t\t\tif(self.queue[item].state===self.DEFINE.QUEUE_ADDED&&self.queueables[self.queue[item].queueable].ready) {\n\t\t\t\t/*\n\t\t\t\t * Update our state to be running\n\t\t\t\t */\n\t\t\t\tself.queue[item].state=self.DEFINE.QUEUE_RUNNING;\n\t\t\t\t/*\n\t\t\t\t * Assign a pid\n\t\t\t\t */\n\t\t\t\tif(self.queue[item].pid===undefined) {\n\t\t\t\t\tself.queue[item].pid = self.pid;\n\t\t\t\t\tself.pid++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Check if any specific timing is needed\n\t\t\t\t */\n\t\t\t\tself.queue[item].options.queueTimer=self.queue[item].options.queueTimer||self.defaultTimer;\n\n\t\t\t\t/*\n\t\t\t\t *  Launch the function as a time out (so we get control back)\n\t\t\t\t */\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tself.queueables[self.queue[item].queueable].start.apply(self.queueables[self.queue[item].queueable],[self.queue[item].pid,self.queue[item].command,self.jsonVars(self.queue[item].json),self]);\n\t\t\t\t}, self.queue[item].options.queueTimer);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find a queue item by searching for its PID\n\t * @param pid\n\t * @return {*}\n\t */\n\tfindQueueByPid(pid) {\n\t\tfor(let item in self.queue) {\n\t\t\tif(self.queue[item].pid===pid) {\n\t\t\t\treturn self.queue[item];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Called by queueables to add something to our memory stack\n\t * @param name\n\t * @param value\n\t * @param pid\n\t */\n\tmemory(pid,value) {\n\t\tlet self=this;\n\t\tlet command=this.findQueueByPid(pid);\n\t\tif(command) {\n\t\t\tlet origin = command.options.memoryName || command.queueable + '.' + command.command;\n\t\t\tlet mode = self.DEFINE.MEMORY_GARBAGE;\n\t\t\tif (command.options.memoryMode)\n\t\t\t\tmode = command.options.memoryMode;\n\t\t\tlet memoryDetails = {\n\t\t\t\tpid: pid,\n\t\t\t\tmode: mode,\n\t\t\t\torigin: origin,\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t\twindow.memory[origin] = memoryDetails;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.reportError(\"Could not set memory\",\"The memory set for pid [\"+pid+\"] could not be found\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Set memory that is not associated with a running queueable (IE from the templates)\n\t * @param name\n\t * @param value\n\t * @param mode\n\t * @return {boolean}\n\t */\n\tsetMemory(name,value,mode) {\n\t\tlet self=this;\n\t\tmode=mode||self.DEFINE.MEMORY_GARBAGE;\n\t\tlet memoryDetails = {\n\t\t\tpid: -1,\n\t\t\tmode: mode,\n\t\t\torigin: 'User',\n\t\t\tvalue: value\n\t\t};\n\t\twindow.memory[name] = memoryDetails;\n\t\tself._updateMemoryPerms();\n\n\t\t\treturn true;\n\t}\n\n\t/**\n\t * Flush any permanent memory to cookies\n\t * @private\n\t */\n\t_updateMemoryPerms() {\n\t\tlet self=this;\n\t\tlet perms=[];\n\t\tlet date = new Date();\n\t\tdate.setTime(date.getTime() + (7 * 24 * 60 * 60 * 1000));\n\t\tlet expires = \"; expires=\" + date.toUTCString();\n\t\tfor(let i in window.memory) {\n\t\t\tif(window.memory[i].mode===self.DEFINE.MEMORY_PERMANENT) {\n\n\t\t\t\tdocument.cookie = 'OT_'+i + \"=\" + window.btoa(JSON.stringify(window.memory[i])) + expires + \"; path=/\";\n\t\t\t\tperms.push(i);\n\t\t\t}\n\t\t}\n\t\tdocument.cookie = 'OT_INDEX' + \"=\" + JSON.stringify(perms) + expires + \"; path=/\";\n\n\t}\n\n\t/**\n\t * Load perm memory items from cookies\n\t * @private\n\t */\n\t_loadMemoryPerms() {\n\t\tlet self=this;\n\t\tlet index=self.getCookie(\"OT_INDEX\");\n\t\tif(index!==null) {\n\t\t\tindex=JSON.parse(index);\n\t\t\tfor(let i in index) {\n\t\t\t\tlet perm=JSON.parse(window.atob(self.getCookie(\"OT_\"+index[i])));\n\t\t\t\twindow.memory[index[i]]=perm;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Retrieve a cookie by name\n\t * @param name - Cookie name\n\t * @returns {*}\n\t */\n\tgetCookie(name) {\n\t\tlet nameEQ = name + \"=\";\n\t\tlet ca = document.cookie.split(';');\n\t\tfor (let i = 0; i < ca.length; i++) {\n\t\t\tlet c = ca[i];\n\t\t\twhile (c.charAt(0) == ' ') c = c.substring(1, c.length);\n\t\t\tif (c.indexOf(nameEQ) == 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Called at the end of a queue run to flush any garbage\n\t * @param pid\n\t */\n\tcleanMemory(pid) {\n\t\tlet self=this;\n\t\tfor(let i in window.memory) {\n\t\t\tif(window.memory[i].pid===pid&&window.memory[i].mode===self.DEFINE.MEMORY_GARBAGE) {\n\t\t\t\twindow.memory[i]={};\n\t\t\t\tdelete window.memory[i];\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t *  Called to flag a queue item as finished\n\t *\n\t *  Normally hooked down from queueable this is a queue item saying I have finished in mode (see define.js)\n\t *\n\t * @param pid\n\t * @param mode\n\t */\n\tfinished(pid,mode,error) {\n\t\tlet self=this;\n\t\tfor(let item in self.queue) {\n\t\t\t/*\n\t\t\t *  Find the queue item we need to finish\n\t\t\t */\n\t\t\tif(self.queue[item].pid===pid) {\n\t\t\t\tself.queue[item].error=error;\n\t\t\t\tif (self.queue[item].state === self.DEFINE.QUEUE_RUNNING) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Did the command return an error? If so we will stop this queue from further execution\n\t\t\t\t\t */\n\t\t\t\t\tif(mode==self.DEFINE.FIN_ERROR) {\n\t\t\t\t\t\tself.queue[item].state=self.DEFINE.QUEUE_ERROR;\n\t\t\t\t\t\tself.reportError(error,'The queueable ['+pid+'] has errored, queue put on hold');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * Was there a warning?. This isn't serious so we just mention it to the console\n\t\t\t\t\t */\n\t\t\t\t\tif(mode==self.DEFINE.FIN_WARNING) {\n\t\t\t\t\t\tconsole.log('Warning: '+error);\n\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Check if this queue has commands left\n\t\t\t\t\t\t */\n\t\t\t\t\tif(self.queue[item].commands!==undefined&&self.queue[item].commands.length>0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Move the next item in the queue down\n\t\t\t\t\t\t */\n\t\t\t\t\t\tself.queue[item].command=self.queue[item].commands[0].command;\n\t\t\t\t\t\tself.queue[item].queueable=self.queue[item].commands[0].queueable;\n\t\t\t\t\t\tself.queue[item].json=self.queue[item].commands[0].json;\n\t\t\t\t\t\tself.queue[item].options=self.queue[item].commands[0].options;\n\t\t\t\t\t\tself.queue[item].commands.shift();\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t *  Update the pid\n\t\t\t\t\t\t *  TODO remove this as queues need to maintain their Pid for memory\n\t\t\t\t\t\t */\n\t\t\t\t\t\t//self.queue[item].pid=self.pid;\n\t\t\t\t\t\t//self.pid++;\n\t\t\t\t\t\tself.queue[item].state = self.DEFINE.QUEUE_ADDED;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Start the queue processor as we just posted a new command\n\t\t\t\t\t\t */\n\t\t\t\t\t\tself.queueProcess();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.queue[item].state = self.DEFINE.QUEUE_FINISHED;\n\t\t\t\t\t\tself.cleanMemory(self.queue[item].pid);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tself.reportError('Cant stop an already stopped process ['+pid+']','Queue is corrupted');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This will take a command string in the format object.command({},{}); and split it down\n\t * into it parts as an object\n\t *\n\t * TODO no concept of the context of the command IE was it from inside a div that need binding?\n\t * @param command {string}\n\t * @return {object}\n\t */\n\tcommandParse(command,isParent) {\n\t\tlet self=this;\n\t\tlet commandObject={};\n\t\t// Find the actual command\n\t\tlet commandArray=command.match(/(.*?)\\(/)[1].split('.');\n\t\tcommandObject.queueable=commandArray[0];\n\t\tcommandObject.command=commandArray[1];\n\t\t// Strip as we go to make follow up regex easier\n\t\tcommand=command.replace(/.*?\\(/,'[');\n\t\t// Find first json arg\n\n\t\tcommand=command.replace(/\\);$/m,']');\n\t\tlet jsonArray=JSON.parse(command);\n\t\tif(jsonArray[0]) {\n\t\t\tcommandObject.json = jsonArray[0];\n\t\t} else {\n\t\t\tcommandObject.json={};\n\t\t}\n\t\t\n\t\tif(jsonArray[1]) {\n\t\t\tcommandObject.options = jsonArray[1];\n\t\t} else {\n\t\t\tcommandObject.options={};\n\t\t}\n\t\t/*\n\t\t * Set our default options if they haven't been set\n\t\t *\n\t\t * We must always have a queueRun object if its not set (normally by instant) then its either an event in\n\t\t * which case it must be a parent or failing then its a sub\n\t\t *\n \t\t */\n\t\tcommandObject.options.queueRun=commandObject.options.queueRun||(isParent? self.DEFINE.COMMAND_EVENT:self.DEFINE.COMMAND_SUB);\n\t\tcommandObject.state=self.DEFINE.QUEUE_ADDED;\n\t\treturn commandObject;\n\t}\n\n\t/**\n\t * Render some text/html to the dom\n\t * @param domObject {object} - The object in the dom to write to\n\t * @param text {string} - The text/HTML to write\n\t * @param mode {number} - Mode to use while writing see define.js\n\t * @return {boolean}\n\t */\n\trenderToDom(domObject,text,mode) {\n\t\tlet self=this;\n\t\tmode=mode||self.DEFINE.RENDER_INSERT;\n\t\tswitch(mode) {\n\t\t\tcase self.DEFINE.RENDER_INSERT:\n\t\t\t\tdomObject.innerHTML=text;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Finds an element in the dom using the jquery formant IE #id .class tag\n\t * @param elementTarget\n\t * @return {object|false}\n\t */\n\tgetElement(elementTarget) {\n\t\tlet self=this;\n\t\tlet element=document.querySelector(elementTarget);\n\t\tif(element!==null)\n\t\t\treturn element;\n\t\tself.reportError('Dom Element find failed for ['+elementTarget+']','Follow up calls that rely on this will fail');\n\t\treturn false;\n\t}\n\n\t/**\n\t *  Show current queue status in the console DEBUG function\n\t */\n\tshow() {\n\t\tlet self=this;\n\t\tfor(let i in self.queue) {\n\t\t\tlet indent=0;\n\t\t\tself.prettyCommandObject(self.queue[i],indent);\n\t\t\tfor(let j in self.queue[i].commands) {\n\t\t\t\tindent++;\n\t\t\t\tself.prettyCommandObject(self.queue[i].commands[j],indent);\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Make a pretty version of the currrent commandObject and dump it to the console\n\t * @param commandObject\n\t * @param indent\n\t */\n\tprettyCommandObject(commandObject,indent) {\n\t\tlet string='';\n\t\tfor(var i=0;i<indent;i++) {\n\t\t\tstring+=' ';\n\t\t}\n\t\tlet color=self.DEFINE.CONSOLE_COL_GREEN;\n\t\tswitch(commandObject.state) {\n\t\t\tcase self.DEFINE.QUEUE_FINISHED:\n\t\t\t\tcolor=self.DEFINE.CONSOLE_COL_AMBER;\n\t\t\t\tbreak;\n\t\t\tcase self.DEFINE.QUEUE_ERROR:\n\t\t\t\tcolor=self.DEFINE.CONSOLE_COL_RED;\n\t\t\t\tbreak;\n\n\t\t}\n\t\tstring+=commandObject.queueable+'.'+commandObject.command+'('+JSON.stringify(commandObject.json)+','+JSON.stringify(commandObject.options)+');'\n\t\tconsole.log('%c '+string,color);\n\t\tif(commandObject.error)\n\t\t\tconsole.log('%c  Stopped: '+commandObject.error,self.DEFINE.CONSOLE_COL_AMBER);\n\t}\n\n\t/**\n\t * Report an error to the console, adds various internal stats\n\t * @param error\n\t * @param message\n\t */\n\treportError(error,message) {\n\t\tconsole.info(self.DEFINE.CONSOLE_LINE);\n\t\tconsole.error('Error:', error);\n\t\tconsole.info(message);\n\t}\n\n\t/**\n\t * Deep copy and object IE remove references\n\t * @param inputObject\n\t * @return {any}\n\t */\n\tdeepCopy(inputObject) {\n\t\treturn JSON.parse(JSON.stringify(inputObject));\n\t}\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Queue);\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/Queue.js?");

/***/ }),

/***/ "./node_modules/@nautoguide/ourthings/Queueable.js":
/*!*********************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/Queueable.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** @module ourthings/Queueable */\n\n/**\n * @classdesc\n *\n * The base class for queueable things\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * // queue = new Queue();\n *\n */\nclass Queueable {\n\n\t/**\n\t * Constructor, Sets our status to be false (flipped on init)\n\t *\n\t */\n\tconstructor() {\n\t\tlet self=this;\n\t\tself.ready=false;\n\t}\n\n\t/**\n\t * init, override this for any promise based inits setting\n\t * the self.ready=true after the promise\n\t *\n\t */\n\tinit(queue) {\n\t\tlet self=this;\n\t\tself.queue=queue;\n\t\tself.ready=true;\n\t}\n\n\t/**\n\t * Called from queue, starts running the actual command\n\t * @param pid\n\t * @param command\n\t * @param json\n\t */\n\tstart(pid,command,json) {\n\t\tlet self=this;\n\t\tif(self[command]&&typeof self[command] === 'function') {\n\n\t\t\t/*\n\t\t\t * Pass the json through the var processor\n\t\t\t */\n\n\t\t\tjson=JSON.parse(self.queue.templateVars(JSON.stringify(json)));\n\t\t\t/*\n\t\t\t * Execute\n\t\t\t */\n\t\t\tself[command](pid, json);\n\t\t} else {\n\t\t\tself.queue.finished(pid,self.queue.DEFINE.FIN_ERROR,'No such command ['+command+']');\n\t\t}\n\t}\n\n\t/**\n\t * Call this method after you command has finished. Failure to do so will result is\n\t * a stalled queue\n\t * @param pid\n\t * @param mode\n\t */\n\tfinished(pid,mode,error='') {\n\t\tlet self=this;\n\t\tself.queue.finished(pid,mode,error);\n\t}\n\n\tset(pid,value) {\n\t\tlet self=this;\n\t\tself.queue.memory(pid,value);\n\t}\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Queueable);\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/Queueable.js?");

/***/ }),

/***/ "./node_modules/@nautoguide/ourthings/Queueable/Elements.js":
/*!******************************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/Queueable/Elements.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Elements; });\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Queueable */ \"./node_modules/@nautoguide/ourthings/Queueable.js\");\n/** @module ourthings/Queueable/Elements */\n\n\n/**\n * @classdesc\n *\n * Dom Elements manipulations\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * //\n *\n */\nclass Elements extends _Queueable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n\t/**\n\t * Add a class to a dom element\n\t * @param {number} pid - Process ID\n\t * @param {object} json - queue arguments\n\t * @param {string} json.targetId - Dom target\n\t * @param {string} json.class - Name of class to add\n\t */\n\taddClass(pid,json) {\n\t\tlet self=this;\n\t\tlet element=self.queue.getElement(json.targetId);\n\t\tself.set(pid,json);\n\n\t\tif(element!==false) {\n\t\t\telement.classList.add(json.class);\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\n\t\t} else {\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_WARNING,'Could not add class ['+json.class+'] to ['+json.targetId+']');\n\t\t}\n\t}\n\n\t/**\n\t * Remove a class to a dom element\n\t * @param {number} pid - Process ID\n\t * @param {object} json - queue arguments\n\t * @param {string} json.targetId - Dom target\n\t * @param {string} json.class - Name of class to remove\n\t */\n\tremoveClass(pid,json) {\n\t\tlet self=this;\n\t\tlet element=self.queue.getElement(json.targetId);\n\t\tself.set(pid,json);\n\n\t\tif(element!==false) {\n\t\t\telement.classList.remove(json.class);\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\n\t\t} else {\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_WARNING,'Could not remove class ['+json.class+'] to ['+json.targetId+']');\n\t\t}\n\t}\n\n    /**\n     * Set the HTML of an element\n     * @param {number} pid - Process ID\n     * @param {object} json - queue arguments\n     * @param {string} json.targetId - Dom target\n     * @param {string} json.html - HTML to add\n     */\n\tinnerHTML(pid,json) {\n\t\tlet self=this;\n\t\tlet element=self.queue.getElement(json.targetId);\n\t\telement.innerHTML=json.html;\n\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\n\n\t}\n}\n\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/Queueable/Elements.js?");

/***/ }),

/***/ "./node_modules/@nautoguide/ourthings/Queueable/Templates.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/Queueable/Templates.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Queueable */ \"./node_modules/@nautoguide/ourthings/Queueable.js\");\n/** @module ourthings/Queueable/Templates */\n\n\n/**\n * @classdesc\n *\n * Template manipulations\n *\n * @author Richard Reynolds richard@nautoguide.com\n *\n * @example\n * // @templates.render({\"targetId\":\"content\",\"template\":\"basic\"});\n *\n */\nclass Templates extends _Queueable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n\t/**\n\t * Render a template into the dom using the queues templateProcessor\n\t * @param {number} pid - Process ID\n\t * @param {object} json - queue arguments\n\t * @param {string} json.template - dom id of template to use\n\t * @param {string} [json.target] - dom id of render target\n\t */\n\trender(pid,json) {\n\t\tlet self=this;\n\t\tself.set(pid,json);\n\t\tif(!self.queue.templateProcessor(json.template,json.targetId))\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_ERROR,'Could not render template');\n\t\telse\n\t\t\tself.finished(pid,self.queue.DEFINE.FIN_OK);\n\t}\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Templates);\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/Queueable/Templates.js?");

/***/ }),

/***/ "./node_modules/@nautoguide/ourthings/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@nautoguide/ourthings/index.js ***!
  \*****************************************************/
/*! exports provided: Queue, Queueable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ \"./node_modules/@nautoguide/ourthings/Queue.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Queue\", function() { return _Queue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _Queueable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queueable */ \"./node_modules/@nautoguide/ourthings/Queueable.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Queueable\", function() { return _Queueable__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/**\n * @module ourthings\n */\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@nautoguide/ourthings/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nautoguide_ourthings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nautoguide/ourthings */ \"./node_modules/@nautoguide/ourthings/index.js\");\n/* harmony import */ var _nautoguide_ourthings_Queueable_Templates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @nautoguide/ourthings/Queueable/Templates */ \"./node_modules/@nautoguide/ourthings/Queueable/Templates.js\");\n/* harmony import */ var _nautoguide_ourthings_Queueable_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nautoguide/ourthings/Queueable/Elements */ \"./node_modules/@nautoguide/ourthings/Queueable/Elements.js\");\n\n\n\n\nwindow.queue = new _nautoguide_ourthings__WEBPACK_IMPORTED_MODULE_0__[\"Queue\"]({\n    templates: _nautoguide_ourthings_Queueable_Templates__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    elements: _nautoguide_ourthings_Queueable_Elements__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n});\n\nmemory['test'] = [];\n\nfor (let i = 0; i <= 100; i++) {\n    memory['test'][i] = {\n        'foo': i,\n        'bar': -i,\n        'value': i % 2 === 1,\n        'array': [\n            {\n                'template': 'renderFoo'\n            },\n            {\n                'template': 'renderBar'\n            }\n        ]\n    }\n}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });