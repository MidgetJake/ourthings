<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ourthings/queue.js | ourthings</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ourthings/define.js~Define.html">Define</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ourthings/queue.js~Queue.html">Queue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ourthings/queueable.js~Queueable.html">Queueable</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#internals">internals</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ourthings/internals/elements.js~Elements.html">Elements</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ourthings/internals/templates.js~Templates.html">Templates</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ourthings/queue.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** @module Queue */
import Define from &apos;./define.js&apos;;


/**
 * @classdesc
 *
 * The main queue class
 *
 * @author Richard Reynolds richard@nautoguide.com
 *
 * @example
 * let queue = new Queue();
 */
export default class Queue {

	/**
	 * Class constructor
	 */
	constructor() {

		self = this;


		/*
		 * Create our DEFINE object for
		 * @type {Define}
		 */
		self.DEFINE = new Define();
		/*
		 * Our Queue array
		 *
		 * @type {Array}
		 */
		self.queue = [];

		/*
		 * Templates to be loaded
		 * @type {Array}
		 */
		self.templates = [];


		/*
		 * Create a fragment for big dom inserts
		 * @type {DocumentFragment}
		 */
		self.fragment = document.createDocumentFragment();

		/*
		 * Se our status
		 * @type {number}
		 */
		self.status = self.DEFINE.STATUS_LOADING;

		/*
		 * Our queue process ID
		 * @type {number}
		 */
		self.pid = 0;

		/*
		 * Default time for process to be executed after
		 * TODO Platform test / tune
		 * @type {number}
		 */
		self.defaultTimer = 10;


		console.clear();
		console.info(self.DEFINE.CONSOLE_LINE);
		console.info(&apos;ourthings framework https://github.com/nautoguide/ourthings&apos;);

		/*
		 * Run init against all our queueables
		 *
		 * This basically passes the queue object (self) though but also for any queueables that require it
		 * starts any promise functions that will result in them becoming active
		 */
		console.log(&quot;[Queueables]&quot;);
		for (let i in window.queueables) {
			window.queueables[i].init(self);
			console.log(&apos;-&apos;+i);
		}

		/*
		 * Load the templates.json
		 */
		fetch(&apos;templates.json&apos;, {
			headers: {
				&apos;Content-Type&apos;: &apos;application/json&apos;
			}
		})
			.then(response =&gt; self.handleFetchErrors(response))
			.then(response =&gt; response.json() )
			.then(function (response) {
				/**
				 * Conver the response to json and start the loader
				 */
				self.templates = response;
				self.templateLoader();
			})
			.catch(function (error) {
				console.info(self.DEFINE.CONSOLE_LINE);
				console.error(&apos;Error:&apos;, error);
				console.info(&quot;Warning this error is probably fatal as I have no templates to load&quot;)
			});
	}

	/**
	 * Error Handler for fetch calls
	 * @param response {object} - Fetch response object
	 * @returns {Object}
	 */
	handleFetchErrors(response) {
		if (!response.ok) {
			self.status=self.DEFINE.STATUS_ERROR;
			throw Error(response.statusText);
		}
		return response;
	}

	/**
	 * Loads templates from the template stack. Recursively calls self until stack is empty
	 * @returns {void}
	 */
	templateLoader() {
		let self=this;
		/*
		 *  Are there any templates to load?
		 *
		 *  If not then we dump the fragment into the dom
		 */
		if (this.templates.length === 0) {
			document.head.appendChild(self.fragment);
			// Clean up the fragment
			self.fragment=document.createDocumentFragment();
			/*
			 * Set our status and then process the init template
			 */
			self.status=self.DEFINE.STATUS_LOADED;
			/*
			 *  TODO once queue generation is working this this pushing to the queue
			 *  As currently this is a chain of promises and so everything will error trap back to the loader
			 */
			self.templateProcessor(&quot;#init&quot;,false);
			self.status=self.DEFINE.STATUS_RUNNING;
			console.info(self.DEFINE.CONSOLE_LINE);
			console.log(&apos;[Online]&apos;);
			console.log(&apos;queue.show(); # To debug the queue&apos;);
			return;
		}

		/*
		 * Pop the template off the stack
		 */
		let template = this.templates.pop();

		fetch(template, {
			headers: {
				&apos;Content-Type&apos;: &apos;test/html&apos;
			}
		})
			.then(response =&gt; self.handleFetchErrors(response))
			.then(response =&gt; response.text())
			.then(function (response) {

				/*
				 * Get the template we were sent and add it to the fragment for insertion into the dom
				 *
				 * We wrap it in meta tag, this helps improve render speed but still stuck with an innerHTML
				 * as we don&apos;t know the content
				 *
				 */
				let text = response;
				let meta = document.createElement(&apos;meta&apos;);
				meta.setAttribute(&quot;name&quot;, &quot;generator&quot;);
				meta.setAttribute(&quot;content&quot;, template);
				meta.innerHTML=text;
				self.fragment.appendChild(meta);

				/*
				 *  Call our self again to process any more templates
				 */
				self.templateLoader();
			})
			.catch(function (error) {
				console.error(&apos;Error:&apos;, error);
				console.info(&quot;Warning this error is probably fatal as a template specified in templates.json has failed to load or wont process&quot;);
			});
	};

	/**
	 * Template processor
	 * Takes a template, process it and places into the dom
	 * @param templateId {string} - ID of the template
	 * @param targetId {string|false} - Place in the dom the put the result. In the event of false we process without dom
	 * @return {boolean} - success status
	 */
	templateProcessor(templateId, targetId) {
		let self=this;
		let commands=[];

		let templateDom = self.getElement(templateId);
		if(!templateDom) {
			self.reportError(&apos;No valid template&apos;,&apos;I have no valid template, check the templateId [&apos;+templateId+&apos;]&apos;);
			return false;
		}
		let targetDom=undefined;
		let templateHTML = templateDom.innerHTML;
		/*
		 * Pass to the templateParse to build our commands
		 */
		let parsedTemplate=self.templateParse(templateHTML,commands);

		/*
		 * Now we pass any var tags {{ }}
		 */
		parsedTemplate=self.templateVars(parsedTemplate);


		if(targetId!==false) {
			targetDom=self.getElement(targetId);
			if(!targetDom) {
				self.reportError(&apos;No valid target&apos;,&apos;I have no valid target to render the template to, check the targetId [&apos;+targetId+&apos;]&apos;);
				return false;
			}
			self.renderToDom(targetDom,parsedTemplate);
			self.commandsBind(commands);
		}
		return true;
	}

	/**
	 * Process the template looking for {{}} instances
	 * @param template
	 * @return {*}
	 */
	templateVars(template) {
		let commandRegex=/{{(.*?)}}/;
		let match=undefined;
		while (match = commandRegex.exec(template)) {
			console.log(match);
			template = template.replace(match[0], self.varsParser(match[1]));
		}
		return template;
	}

	/**
	 * parse a var string
	 *
	 * TODO This is massively insecure. If as user can input {{}} into a form and have it displayed
	 * to other users they can take over. We either clean all input as you would with &lt;script&gt; etc tags or we
	 * manually write a parser.
	 *
	 * @param parseString
	 * @return {any}
	 */
	varsParser(parseString) {
		return eval(parseString);
	}

	/**
	 * Takes a template and runs any template commands contained in it to create a HTML template
	 * ready to be put into the dom
	 *
	 * @param template {string}
	 * @return {string}
	 */
	templateParse(template,commands) {
		let commandRegex=/[@\-](.*?\);)/;
		let match=undefined;
		let parentCommand;
		let isParent;
		/*
		 *  Locate all the commands in the template and generate an array of command objects that
		 *  are linked by a reference into the template
		 */
		while (match = commandRegex.exec(template)) {
			isParent=match[0][0]===&apos;@&apos;;
			/*
			 * Generate this command object from the extracted string
			 */
			let command=self.commandParse(match[1],isParent);

			/*
			 *  In the case of an instant or sub run we don&apos;t need to leave anything in the DOM so nuke
			 */
			if(command.options.queueRun===self.DEFINE.COMMAND_INSTANT||command.options.queueRun===self.DEFINE.COMMAND_SUB) {
				template = template.replace(match[0], &quot;&quot;);
			} else {
				template = template.replace(match[0], &quot;data-queueable=\&quot;CMD&quot; + commands.length + &quot;\&quot;&quot;);
			}
			/*
			 *  Is this a @parent or a -child?
			 */
			if(isParent) {
				// Set the parent point to current position
				parentCommand=commands.length;
				/*
				 *  Is this an event (in which case we need to bind events later). We know this use case because an
				 *  event will not be instant and it will be a parent
				 */
				if(command.options.queueRun!==self.DEFINE.COMMAND_INSTANT) {
					/*
					 *  We need to re-extract the command from the template and find the HTML element that this
					 *  belongs to
					 *
					 *  TODO Stub for now as we need to get a working queue first
					 */
					//let elementMatch=template.match(//)
				}

				commands.push(command);
			} else {
				// If the parent has just been created it won&apos;t have child structure
				if(commands[parentCommand].commands===undefined) {
					commands[parentCommand].commands=[];
				}
				// Put the command in the parents
				commands[parentCommand].commands.push(command);
			}
		}
		// Add the instants to the active queue
		self.commandsQueue(commands);
		return template;
	}

	/**
	 * Bind the events to the dom based on the command Object
	 * @param commandObj
	 */
	commandsBind(commandObj) {
		let self=this;
		for(let command in commandObj) {
			/*
			 * Bind queue elements will not me marked to run instantly so we pick those
			 */
			if(commandObj[command].options.queueRun!==self.DEFINE.COMMAND_INSTANT) {
				/*
				 * Find its dom entry using the selector we added
				 */
				let element=self.getElement(&quot;[data-queueable=CMD&quot;+command+&quot;]&quot;);

				/*
				 * Add the event. We flip it over to an instant event now because we want
				 * it triggered.
				 */
				element.addEventListener(&quot;click&quot;, function(){
					commandObj[command].options.queueRun=self.DEFINE.COMMAND_INSTANT;
					self.commandsQueue.apply(self,[[commandObj[command]]]);
				});
			}
		}

	}

	/**
	 * Take the commands array with command objects in it and add them to the queue *if* they are
	 * marked as instant. IE ready to execute
	 *
	 * @param commandObj
	 */
	commandsQueue(commandObj) {
		let self=this;
		for(let command in commandObj) {
			if(commandObj[command].options.queueRun===self.DEFINE.COMMAND_INSTANT) {
				let dereference=self.deepCopy(commandObj[command])
				self.queue.push(dereference);
			}
		}
		/*
		 *  Trigger a queue process
		 */
		self.queueProcess();
	}

	/**
	 * Force a queue processing
	 *
	 * This launches the actual objects using a timeout
	 */
	queueProcess() {
		let self=this;
		/*
		 *  TODO Only implementing basic queue here for testing. Concepts of active componets etc need importing
		 *  for moho
		 */
		for(let item in self.queue) {
			/*
			 *  Look for items that are QUEUE_ADDED as they need processing
			 *
			 *  Ensure the component is online
			 */
			if(self.queue[item].state===self.DEFINE.QUEUE_ADDED&amp;&amp;window.queueables[self.queue[item].queueable].ready) {
				/*
				 * Update our state to be running
				 */
				self.queue[item].state=self.DEFINE.QUEUE_RUNNING;
				/*
				 * Assign a pid
				 */
				self.queue[item].pid=self.pid;
				self.pid++;
				/*
				 * Check if any specific timing is needed
				 */
				self.queue[item].options.queueTimer=self.queue[item].options.queueTimer||self.defaultTimer;

				/*
				 *  Launch the function as a time out (so we get control back)
				 */

				setTimeout(function () {
					window.queueables[self.queue[item].queueable].start.apply(window.queueables[self.queue[item].queueable],[self.queue[item].pid,self.queue[item].command,self.queue[item].json,self]);
				}, self.queue[item].options.queueTimer);
			}
		}
	}

	/**
	 *  Called to flag a queue item as finished
	 *
	 *  Normally hooked down from queueable this is a queue item saying I have finished in mode (see define.js)
	 *
	 * @param pid
	 * @param mode
	 */
	finished(pid,mode,error) {
		let self=this;
		for(let item in self.queue) {
			/*
			 *  Find the queue item we need to finish
			 */
			if(self.queue[item].pid===pid) {
				self.queue[item].error=error;
				if (self.queue[item].state === self.DEFINE.QUEUE_RUNNING) {
					/*
					 * Did the command return an error? If so we will stop this queue from further execution
					 */
					if(mode==self.DEFINE.FIN_ERROR) {
						self.queue[item].state=self.DEFINE.QUEUE_ERROR;
						self.reportError(error,&apos;The queueable [&apos;+pid+&apos;] has errored, queue put on hold&apos;);
						return;
					}
					/*
					 * Was there a warning?. This isn&apos;t serious so we just mention it to the console
					 */
					if(mode==self.DEFINE.FIN_WARNING) {
						console.log(&apos;Warning: &apos;+error);
					}
						/*
						 *
						 * Check if this queue has commands left
						 */
					if(self.queue[item].commands!==undefined&amp;&amp;self.queue[item].commands.length&gt;0) {
						/*
						 * Move the next item in the queue down
						 */
						self.queue[item].command=self.queue[item].commands[0].command;
						self.queue[item].queueable=self.queue[item].commands[0].queueable;
						self.queue[item].json=self.queue[item].commands[0].json;
						self.queue[item].options=self.queue[item].commands[0].options;
						self.queue[item].commands.shift();
						/*
						 *  Update the pid
						 */
						self.queue[item].pid=self.pid;
						self.pid++;
						self.queue[item].state = self.DEFINE.QUEUE_ADDED;
						/*
						 * Start the queue processor as we just posted a new command
						 */
						self.queueProcess();
					} else {
						self.queue[item].state = self.DEFINE.QUEUE_FINISHED;
					}
					return;
				} else {
					self.reportError(&apos;Cant stop an already stopped process [&apos;+pid+&apos;]&apos;,&apos;Queue is corrupted&apos;);
					return;
				}
			}
		}
	}

	/**
	 * This will take a command string in the format object.command({},{}); and split it down
	 * into it parts as an object
	 *
	 * TODO no concept of the context of the command IE was it from inside a div that need binding?
	 * @param command {string}
	 * @return {object}
	 */
	commandParse(command,isParent) {
		let self=this;
		let commandObject={};
		// Find the actual command
		let commandArray=command.match(/(.*?)\(/)[1].split(&apos;.&apos;);
		commandObject.queueable=commandArray[0];
		commandObject.command=commandArray[1];
		// Strip as we go to make follow up regex easier
		command=command.replace(/.*?\(/,&apos;&apos;);
		// Find first json arg
		let json=command.match(/(\{.*?\})/);
		command=command.replace(/\{.*?\}[,]{0,1}/,&apos;&apos;);
		if(command[1]) {
			commandObject.json = JSON.parse(json[1]);
		} else {
			commandObject.json={};
		}

		// Find second json arg
		let jsonOptions=command.match(/(\{.*?\})/);
		if(Array.isArray(jsonOptions) &amp;&amp; jsonOptions[1]) {
			commandObject.options = JSON.parse(jsonOptions[1]);
		} else {
			commandObject.options={};
		}
		/*
		 * Set our default options if they haven&apos;t been set
		 *
		 * We must always have a queueRun object if its not set (normally by instant) then its either an event in
		 * which case it must be a parent or failing then its a sub
		 *
 		 */
		commandObject.options.queueRun=commandObject.options.queueRun||(isParent? self.DEFINE.COMMAND_EVENT:self.DEFINE.COMMAND_SUB);
		commandObject.state=self.DEFINE.QUEUE_ADDED;
		return commandObject;
	}

	/**
	 * Render some text/html to the dom
	 * @param domObject {object} - The object in the dom to write to
	 * @param text {string} - The text/HTML to write
	 * @param mode {number} - Mode to use while writing see define.js
	 * @return {boolean}
	 */
	renderToDom(domObject,text,mode) {
		let self=this;
		mode=mode||self.DEFINE.RENDER_INSERT;
		switch(mode) {
			case self.DEFINE.RENDER_INSERT:
				domObject.innerHTML=text;
				break;
		}
		return true;
	}

	/**
	 * Finds an element in the dom using the jquery formant IE #id .class tag
	 * @param elementTarget
	 * @return {object|false}
	 */
	getElement(elementTarget) {
		let self=this;
		let element=document.querySelector(elementTarget);
		if(element!==null)
			return element;
		self.reportError(&apos;Dom Element find failed for [&apos;+elementTarget+&apos;]&apos;,&apos;Follow up calls that rely on this will fail&apos;);
		return false;
	}

	/**
	 *  Show current queue status in the console DEBUG function
	 */
	show() {
		let self=this;
		for(let i in self.queue) {
			let indent=0;
			self.prettyCommandObject(self.queue[i],indent);
			for(let j in self.queue[i].commands) {
				indent++;
				self.prettyCommandObject(self.queue[i].commands[j],indent);

			}
		}
	}

	/**
	 * Make a pretty version of the currrent commandObject and dump it to the console
	 * @param commandObject
	 * @param indent
	 */
	prettyCommandObject(commandObject,indent) {
		let string=&apos;&apos;;
		for(var i=0;i&lt;indent;i++) {
			string+=&apos; &apos;;
		}
		let color=self.DEFINE.CONSOLE_COL_GREEN;
		switch(commandObject.state) {
			case self.DEFINE.QUEUE_FINISHED:
				color=self.DEFINE.CONSOLE_COL_AMBER;
				break;
			case self.DEFINE.QUEUE_ERROR:
				color=self.DEFINE.CONSOLE_COL_RED;
				break;

		}
		string+=commandObject.queueable+&apos;.&apos;+commandObject.command+&apos;(&apos;+JSON.stringify(commandObject.json)+&apos;,&apos;+JSON.stringify(commandObject.options)+&apos;);&apos;
		console.log(&apos;%c &apos;+string,color);
		if(commandObject.error)
			console.log(&apos;%c  Stopped: &apos;+commandObject.error,self.DEFINE.CONSOLE_COL_AMBER);
	}

	/**
	 * Report an error to the console, adds various internal stats
	 * @param error
	 * @param message
	 */
	reportError(error,message) {
		console.info(self.DEFINE.CONSOLE_LINE);
		console.error(&apos;Error:&apos;, error);
		console.info(message);
	}

	/**
	 * Deep copy and object IE remove references
	 * @param inputObject
	 * @return {any}
	 */
	deepCopy(inputObject) {
		return JSON.parse(JSON.stringify(inputObject));
	}

}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
