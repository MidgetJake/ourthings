<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Ourthings</title>
    <link type="text/css" rel="stylesheet" href="css/docs.css">
	<link rel="stylesheet"
	      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/darcula.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>
<body>
<h1><img src="images/logo.png"></h1>

<h1>Command Reference</h1>
<h2>Overview</h2>
<p>ourthings has two formats for interacting with your templates. One is a traditional approach that
    will be familair to users fo existing templating libraries such a mostache and jsrender and the second
    and more powerful queue system that is unique to ourthings. We refer to them as template *tags* and
    *queueables*.</p>
<h3>Queuables</h3>
<p>Queueables are javascript modules that can be called from inside your templates to perform a wide range
    of functions. This can range from changing the class of an element in the page to making a rest API call
    or moving a map around.</p>

<p>The simplist invocation and possibly the most frequent used example is that of rendering a template
    to the DOM.</p>
<pre><code>@templates.render({"targetId":"#content","template":"#basic"},{"queueRun":"Instant"});</code></pre>
<p>Breaking this down the command format is defined as</p>
<pre><code>@<span class="arg">queueable</span>.<span class="arg">command</span>(<span class="arg">arguments</span>,<span class="arg">options</span>);</code></pre>
<ul>
	<li><span class="arg">queueable</span> - The queueable module you wish to use</li>
	<li><span class="arg">command</span> - The command in the module you wish to use</li>
	<li><span class="arg">arguments</span> - Arguments to pass ro the command in json format</li>
	<li><span class="arg">options</span> - Options to pass to the queue processor</li>
</ul>
<p>If you are familar with the javascript OO model then queueable.command() will already be very familar to you
and you can translate that to directly running a function in javascript from the html page. queueables
are very much built in this fashion by extending a class and writing functions. We also want to pass arguments
to that function and you do this by sending some json in which the function will be given.</p>
<p>Options are things you want to instruct the queue handler to do with this item in the queue. This can range from
delaying execution, running instantly or waiting for the user to hit a button see the command options sections
for a list of these</p>
</body>
<h4>Command Options</h4>
<ul>
	<li><span class="arg">queueRun</span> Instant|Event|Sub</li>
	<li><span class="arg">queueTimer</span> Delay run in ms, default is 10</li>
	<li><span class="arg">queuePrepare</span> Put this queue in the prepare list ready for use when called</li>
	<li><span class="arg">queueEvent</span> Defaults to "click", supports any javascript event type</li>
	<li><span class="arg">memoryName</span> If this function outputs to memory set the name</li>
	<li><span class="arg">memoryMode</span> Memory will last [Garbage|Session|Permanent]</li>
</ul>
<h3>Template Commands</h3>
<h4>{{}} & {{!}} & {{!^}}</h4>
<p>Ourthings supports a standard template of {{something}} that allows the execution of javascript
to place values in the page. This format can used in two ways.</p>
<p>1. Placing values in a rendered template at render time EG {{memory.foo}} will output the value window.foo</p>
<p>2. Passing values to argument lists in queueables at command execution time using {{!memory.foo}}</p>
<p>Its important to understand when you need to use {{}} and {{!}}. If you are simply displaying data in a template use
	{{}}. This is because when that template is shown to the user you want the value it represents at that time. If however
	you have a queue and the last item in that queue depends on a value that may change as a result of that queues preceding commands
	(EG an api call) then you want {{!}}. The variant {{!^}} can be used to remove surrounding quotes when injecting JSON into JSON for example</p>

<pre><code>@api.post({"url":"{{config.api}}api/","body":{"_token":"{{!memory.token.value}}","schema":"{{!memory.sub.value}}","app":"boundary","api":"reporting_api","action":"run_report","payload":{"report_name": "set_system_config","_param_1":"{{!^JSON.stringify(memory.configAPI.value.API.Response.system_config)}}"}}});</code></pre>

<p>Without the {{!^}} the JSON that is being inserted to the JSON string would be quoted causing a parsing error. The above example contains correct usage of all formats.
{{config.api}} - This never changes so we can render at template render time. {{!memory.token.value}} - This value can change at any time, "{{!^JSON.stringify(memory.configAPI.value.API.Response.system_config)}}" -
will produce JSON so we need to remove the ""</p>

<p>Both type of template commands are not supported in the root document. IE if you have an index.html you can not use any template commands in there. This is because
the browser will have rendered the page before the framework is online and so depending on load speed there would be a period of time where these template commands
could be visible to the user and cause a pop-in affect. Through development of previous version where we did allow this we found it caused bad practice in app creation or the
need for loading animations which is generally not good practice. The developer should consider the root document as what the user/bot will first see and then build out dynamic
content using the init command queue which is executed when the browser has finished loading all content.
the system is online</p>
<h4>{{#include [#template]}}</h4>
If you want to include a template (normally for reuse purposes) into the template you using then use {{#include}}.

<pre><code>&lt;script id="myTemplayeId" type="text/html"&gt;
	blah
&lt;/script&gt;

{{#include #myTemplayeId}}</code></pre>

<p>This would result in 'blah' replacing {{#include #myTemplayeId}}</p>

<h4>{{#for [variable]}}</h4>
Loop though an array or object
<pre><code>{{#for memory.people.value}}
  {{memory.people.value[#loop0].name}}
{{/for}}</code></pre>

<p>#loop0 will be replaced with the array index of object key</p>

<h4>{{#if [test]}}</h4>
Perform a if
<pre><code>{{#if memory.people.value.length>0}}
	There are people
{{else}}
	There are not any people
{{/if}}</code></pre>
</html>


